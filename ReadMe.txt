Проект по созданию сервера для работы с транспортными картами
=============================================================
                        Тех. задание

Карты могут быть кредитными и дебетовыми
Кредитные карты - именные, с возможностью ездить в долг
Дебетовые карты - безымянные, без возможности задолжать

Операции по картам:
- оплата по тарифу в зависимости от транспорта
- пополнение счета
- просмотр баланса
- блокировка карты

Необходимо хранить историю операций по картам в БД
Подробное логирование событий

Написать эмулятор обращения к сервису
=============================================================
                Принцип работы приложения

- Созданная карта вносится в БД
- БД имеет две таблицы: Card и History
- Card:
       cardId VARCHAR(36) NOT NULL,         //UUID()
       balance DECIMAL(8, 2) NOT NULL,
       type VARCHAR(6),
       cutOffBankDept DECIMAL(5, 2) NOT NULL,
       isBlocked BOOLEAN NOT NULL,
       PRIMARY KEY(cardID);

- History:
        cardId VARCHAR(255) NOT NULL,
        operation VARCHAR(36) NOT NULL,
        result BOOLEAN NOT NULL,
        amount VARCHAR(255) NOT NULL,
        date VARCHAR(255) NOT NULL,
        balanceAfterOperation VARCHAR(255) NOT NULL,
        PRIMARY KEY(cardID);

JOIN по cardID
- В зависимости от вида транспорта будет списываться определенная сумма
- Карты, в зависимости от их типа(кредитные или дебетовые), будут иметь опцию поездок в долг
- Иметь индивидуальный Id
- Также будут иметь возможность оплачивать поездку, пополнять счет, смотреть статус
- Логика работы терминала будет подразумевать через cardID производить оплату поездки,
  оплату поездки в долг, пополнение счета, блокировку и создание карты
- Терминал будет связан с сервером, а сервер с БД
- Admin подразумевается как контроллер с полным набором функций. Способен будет производить
  оплату проезда, поездки в долг, пополнение счета, предоставление баланса, хранение истории
  операций и блокировку карт
- ID терминала хранить в истории


Уже сделано:
Абстрактный класс реализующий интерфейс
Enum с видами карт
Классы карт, расширяющие абстрактный класс
Enum транспорта со стоимостью проезда
Класс сервиса карт
Класс сервиса оплаты
Класс, временно заменяющий БД
Контроллер Терминал
Контроллер Админ
MySQL файл со скриптами
Создать 10 тестовых карт
Использовать JDBC(вместо списка карт, которые хранятся в памяти программы)
Переместить скрипт инициализации БД в случае отсутствия базы данных
Тесты на контроллеры и сервис классы
Добавить тесты
Переместить в application.yml настройки, которые в коде
Поменять JDBC на Hibernate

Осталось сделать:
- Написать эмулятор:
Задача эмулятора - протестировать приложение, как если бы обращалось одновременно много
клиентов (терминалов) с различными запросами в течение определённого периода времени.

Эмулятор должен получить список карт на старте, и случайным образом выбирать операции оплаты,
 пополнения и просмотра баланса, блокировки и разблокировки, а так же создание новых карт
  и последующее их добавление в уже существующий список карточек, которые были получены изначально.

Выбор операции должен иметь определённую разумную вероятность.

Например:
4% вероятности того, что пользователь положил деньги на счёт
(случайная сумма в определённых пределах)
90% вероятности, что сгенерируется запрос на списание денег (тип транспорта выбирать с равной вероятностью)
1% на то, что карта должна быть заблокирована и столько же на обратную операцию
3% на то, что будет запрос баланса
1% на создание новой карточки

Все операции должны быть тщательно залогированы.

Все эти операции должны работать в n потоков
(конкретное число потоков должно задаваться через параметры командной строки при запуске)

Так же эмулятор должен работать ограниченное количество минут
(время так же должно быть передано через параметры)

Протестировать приложение с помощью этого эмулятора с разным количеством потоков
 и разным временем работы. Результаты записать в readme.

Как минимум:
4 потока, 5 минут
10 потоков 5 минут
40 потоков 2 минуты

Найти максимум того, на что способен компьютер.

Задача со звёздочкой на будущее - определить методы,
которые занимают наибольшее количество времени работы программы,
 подумать, как можно их оптимизировать, чтобы программа работала быстрее,
  соответственно, была бОльшая пропускная способность приложения.


